### 关于JS中, 对引用类型console出现偏差的问题分析



> key   `引用类型  `  `内存`   `同步执行`  `console.log`

![image-20200415113640632](https://tva1.sinaimg.cn/large/007S8ZIlgy1gduax3tpz6j30c908imx8.jpg)

Q :

		 Array(1) 但是有两个值

A : 

首先，我们要明白，数组是一个引用类型，即，变量名只是指向内存地址的指针

其次，在上图中，我们是先声明一个 变量 a，指向一个数组[1]，随后进行打印，再接着是对数组进行push操作。OK，潜意识里，我们认为js是单进程且顺序执行，并且代码块中都是同步的，所以我们会觉得打印出来是push操作之前的数组，但实际上，显示Array的长度是1，当我们查看元素, 反而是push后的，出现了偏差。

这是为什么呢？   让我们思考加探索一下。



Music，Let's go

1. 上面我们指出，数组是引用类型，变量是个指针指向内存地址，数组的push操作，是在一段连续的内存上增加一个值
2. 由于都是同步语句，那么就顺序执行。在console的时候，显示数组长度1
3. console在打印的时候，确实是Array(1),  紧接着该变量指针 数组执行了push操作, 这时候代码块已经执行完. 
4. **但在随后查看的时候元素却是两个,  显示出了偏差 !**
5. **这里为什么出现了显示不一致的情况?**
6. 原来, **console打印引用类型的操作, 是先打印引用类型的快照,  在展开对象的时候, 会再次去读取变量指针的值**, 而此时, 代码块已经执行完了, 即push操作已经生效, 变量指针指向的值已经更改,  所以读取的是push操作后的值. 所以出现了Array(1), [0: 1, 1: 2] 的情况。

事实是如此吗, 我们简单验证一下

1. console.log的时候, 顺便打印key, ( 因为数组也是对象, 所以可以keys)

    ![image-20200415131425784](https://tva1.sinaimg.cn/large/007S8ZIlgy1gdudllp8snj30kh08uq54.jpg)

2. 使用断点验证

    ![image-20200415131717882](https://tva1.sinaimg.cn/large/007S8ZIlgy1gdudol5fpjj31330ox0zt.jpg)

    在使用断点后, 第一次打印的数据, 展开后是push操作前的值, 代码块执行完后, 再次展开还是一个元素. 

上面两种方式, 说明了console操作对于引用类型, 是有两次读取的. 第二次来自首次展开对象. 